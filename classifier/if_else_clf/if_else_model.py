# -*- coding: utf-8 -*-
"""數位醫學 smoke_stat_det

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ISc5Pdc9G3BdR2BvDoYN31uEza4cc9GK
"""

#include <iostream>
#include <fstream>
#include <algorithm>
#include <vector>
#include <string>
#include <cctype>

using namespace std;

struct Index
{
    int i = -1;
    int j = -1;
};

bool exist_word(const vector<string> &data, const string word);
bool exist_word(const vector<string> &data, const vector<string> &words);
bool exist_word(const vector<string> &data, const vector<string> &words, const Index ind, const size_t fr, const size_t br);
bool exist_all_words(const vector<string> &data, const vector<string> &words);
Index exist_word_loc(const vector<string> &data, const string word);
Index exist_word_loc(const vector<string> &data, const vector<string> &words);

int main()
{
    //input data

    constexpr int data_size = 40;
    ofstream outfile("answer.txt");
    if(!outfile)
        return 2; // fail to open
    for(int i = 1 ; i<= data_size; i++)
    {
        string in_fname("Case 1 testing data\\TEST_");
        char c0 = '0' + i / 10;
        char c1 = '0' + i % 10;
        in_fname += c0;
        in_fname += c1;
        in_fname +=".txt";
        cout<<in_fname<<endl;

        ifstream infile;

        infile.open( in_fname, ifstream::in);
        if(!infile)
            return 1; // fail to open

        //initialize

        vector<string> data;

        const vector<string> smoke_words ({"tobacco", "cigarette", "smokes", "smoke", "smoker", "smoking", "ppd"});
        const vector<string> risk_words({"copd", "emphysema", "chronic bronchitis", "lung cancer"});
        const vector<string> smoke_meds({"berotec", "atrovent", "meptin"});
        const vector<string> non_smoke_meds({"atenolol"});
        const vector<string> smoke_combo1({"right pleural effusion", "no fever", "weight loss"});
        const vector<string> smoke_combo2({"left pleural effusion", "no fever", "weight loss"});
        const vector<string> smoke_combo3({"hypoxia", "dyspnea", "wheezing", "no fever"});
        const vector<string> negative_words({"denies", "not", "no"});
        const vector<string> past_words({"quit", "past", "former"});

        constexpr int front_relative_length = 35;
        constexpr int back_relative_length = 15;

        while(infile) // input to data
        {
            string input;
            getline(infile, input);
            transform(input.begin(), input.end(), input.begin(), [](unsigned char c)
            {
                return tolower(c);
            });
            data.push_back(input);
        }

        /* test output data
        for(size_t i = 0; i<data.size(); i++)
        {
            cout<<data[i]<<endl;
        }
        */

        if(exist_word(data, smoke_words))//smoke
        {
            Index ind = exist_word_loc(data, smoke_words);
            if(exist_word(data, negative_words, ind, front_relative_length, back_relative_length))//negative
            {
                cout<<"non smoker"<<endl;
                outfile<<"non smoker"<<endl;
            }
            else//time
            {
                if(exist_word(data, past_words, ind, front_relative_length, back_relative_length))
                {
                    cout<<"past smoker"<<endl;
                    outfile<<"past smoker"<<endl;
                }
                else
                {
                    cout<<"current smoker"<<endl;
                    outfile<<"current smoker"<<endl;
                }
            }
        }
        else
        {
            if(exist_word( data, risk_words))
            {
                cout<<"past smoker"<<endl;
                outfile<<"past smoker"<<endl;
            }
            else if(exist_all_words(data, smoke_combo1) || exist_all_words(data, smoke_combo2) || exist_all_words(data, smoke_combo3))// special combination
            {
                cout<<"past smoker"<<endl;
                outfile<<"past smoker"<<endl;
            }
            else if(exist_word(data, non_smoke_meds))
            {
                cout<<"non smoker"<<endl;
                outfile<<"non smoker"<<endl;
            }
            else//unknown
            {
                cout<<"unknown"<<endl;
                outfile<<"unknown"<<endl;
            }
        }
        cout<<endl;
    }
}

bool exist_word(const vector<string> &data, const string word)
{
    for(size_t i = 0; i<data.size(); i++)
    {
        if(data[i].find(word) != string::npos)
            return true;
    }
    return false;
}

bool exist_word(const vector<string> &data, const vector<string> &words)
{
    for(size_t i = 0; i < data.size(); i++)
    {
        for(size_t j = 0; j < words.size(); j++)
        {
            if(data[i].find(words[j]) != string::npos)
                return true;
        }
    }
    return false;
}

bool exist_word(const vector<string> &data, const vector<string> &words, const Index ind, const size_t fr, const size_t br)
{
    for(size_t j = 0; j < words.size(); j++)
    {
        if(data[ind.i].find(words[j]) != string::npos)
        {
            int loc = data[ind.i].find(words[j]);
            //cout<<"find"<<loc<<"near"<<ind.j<<endl;
            if(ind.j - loc <= (int)fr && loc - ind.j <= (int)br)
                return true;
        }
    }
    return false;
}

bool exist_all_words(const vector<string> &data, const vector<string> &words)
{
    size_t count = 0;
    for(size_t i = 0; i < words.size(); i++)
    {
        if(exist_word(data, words[i]))
        {
            count += 1;
        }
    }
    if(count == words.size())
        return true;
    else
        return false;
}

Index exist_word_loc(const vector<string> &data, const string word)
{
    Index target;
    for(size_t i = 0; i<data.size(); i++)
    {
        if(data[i].find(word) != string::npos)
        {
            target.i = (int)i;
            target.j = (int)data[i].find(word);
            break;
        }
    }
    return target;
}

Index exist_word_loc(const vector<string> &data, const vector<string> &words)
{
    Index target;
    for(size_t i = 0; i < data.size(); i++)
    {
        for(size_t j = 0; j < words.size(); j++)
        {
            if(data[i].find(words[j]) != string::npos)
            {
                target.i = (int)i;
                target.j = (int)data[i].find(words[j]);
                return target;
            }
        }
    }
    return target;
}